/**
 * @file liunx_cpp
 * @author qingshan wu
 * @brief  liunx c/cpp 服务器编程 
 * @version 0.1
 * @date 2022-03-09
 * 
 * @copyright Copyright (c) 2022
 * 
 */


#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <fcntl.h>     //文件io 文件控制 文件锁
#include <sys/types.h> //文件io
#include <sys/stat.h>  //文件io
#include <signal.h>
#include <pthread.h>
#include<semaphore.h>  //信号量头文件
#include <sys/socket.h>  
#include <netinet/in.h>     //ip转换
#include <arpa/inet.h>      //网络字节序转换
int main(int argc,char *argv[])
{
//环境变量相关函数 lib
#if 0                    
extern char** environ;   //引入环境变量PATH，SHELL,TERM,LANG,HOME
char *val;
const char *name = "ABD";
setenv(name,"val",1);   //设置环境变量的值 1是覆盖原环境变量 0 不覆盖
val=getenv(name);       //获取环境变量的值
unsetenv(name);         //删除环境变量的值
#endif

//进程控制 子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。 共享文件描述符
//读时共享，写时复制
#if 0
pid_t pid;                      //进程id
pid=fork();                     //创建一个子进程
if (pid == -1 )                 //失败返回-1
    {  
        perror("fork 失败");
        exit(1);
    }
     else if (pid > 0) {       //父进程返回子进程id
        pid_t wid;
        int *status;
        wid=wait(status);       //成功：清理掉的子进程ID；失败：-1 (没有子进程),status退出状态 一次调用只能关闭一个
        //wid=waitpid(pid,status,WNOHANG); //PID大于0，回收指定子进程，-1回收任意，0当前进程组所有，<-1指定进程组任意

        printf("I'm parent");   
    } else if (pid == 0) {      //子进程返回0 
        printf("I'm child");
    }
         //getpid getppid getuid getgid 
#endif

//系统io函数
#if 0
int fd=open("./test.txt",O_RDWR);           //打开文件 标志位有O_RDONLY 只读O_WRONLY 只写O_RDWR 读写O_APPEND 追加                      
int fd1=open("./test1.txt",O_CREAT|O_TRUNC|O_WRONLY,0644);//O_CREAT 创建文件O_NONBLOCK 非阻塞,0677是权限位 成功返回文件描述符，失败-1
fflush(fd);                    //buffer刷新，写

int flags =fcntl(fd,F_GETFL);   //获得现有标志位
flags |=O_NONBLOCK;             //添加非阻塞标志
fcntl(fd,F_SETFL,flags);        //操作文件，改变属性 F_SETFL 设置flag

char buf[256]={0};
int ret=0;
while((ret=read(fd,buf,sizeof(buf)))!=0)   //读文件到buf 失败返回-1，成功返回读到字节数，0代表读完
{
    if(ret=-1)
        return -1;
}
ret=write(fd1,buf,sizeof(buf));     //-1失败 0未读入 >0读到的字节数
if(ret=-1) perror("write 失败"); 
iseek(fd1,0,SEEK_SET);              //重定位读/写文件de偏移量，失败-1，成功返回当前位置到文件开头的长度0偏移量，SEEK_SET 文件开始SEEK_CUR 文件当前位置SEEK_END 文件结尾
close(fd);
close(fd1);




#endif

//exec 函数族 将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变
#if 0
#endif

//进程间通信，内核中开辟缓冲区
//1.管道，作用于血缘关系之间，伪文件，环形队列，两个文件描述符，写端流入读端流出，不可反复读取
#if 0
    pid_t pid;
    char buf[1024];
    int fd[2];
    char *p = "test for pipe\n";
    if (pipe(fd) == -1)      //成功：0；失败：-1， 
    perror("pipe 创建失败");
    pid = fork();
    if (pid < 0) {
       perror("fork err");
   } else if (pid == 0) {    //子进程关闭写端，读数据
        close(fd[1]);
        int len = read(fd[0], buf, sizeof(buf));
        write(STDOUT_FILENO, buf, len);
        close(fd[0]);
   } else {
       close(fd[0]);               //父进程关闭读端，写数据
       write(fd[1], p, strlen(p));
       wait(NULL);
       close(fd[1]);
   }
#endif

/*2.FIFO命名管道，不相关进程通信,各进程可以打开这个文件进行read/write
mkfifo 管道名
一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write*/

//3.共享存储映射 a.父子进程共享文件描述符。也就共享打开的文件。
// b.存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。
#if 0
char *mem;
int fd = open("hello244", O_RDWR|O_CREAT|O_TRUNC, 0644);
mem = mmap(NULL, 20, PROT_WRITE, MAP_SHARED, fd, 0);     //成功：返回创建的映射区首地址；失败：MAP_FAILED宏 NULL Linux内核指定建立映射区的首地
  //20映射区的大小,映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE
  //MAP_SHARED会将映射区所做的操作反映到物理设备（磁盘）上 MAP_PRIVATE不会 0是映射文件的偏移量
 if (mem == MAP_FAILED)    
    perror("mmap err: ");
 close(fd);
 munmap(mem,  20);   //释放映射区，mem必须是没有改变的，20是大小
#endif

//父子进程共享：1. 打开的文件  2. mmap建立的映射区(但必须要使用MAP_SHARED)
//匿名映射,int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);  不需要文件描述符 传-1

//mmap无血缘关系进程间通信
#if
    int fd;
    string student =  "xiaoming";
    char *mm;
    fd = open(argv[1], O_RDWR | O_CREAT, 0664);          //两个进程用同一个文件创建mmap
    ftruncate(fd, sizeof(student));
    mm = mmap(NULL, sizeof(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    close(fd);
    while (1) {
    memcpy(mm, &student, sizeof(student));               //读写时使用指针
    student.id++;
    sleep(1);
    }

    munmap(mm, sizeof(student));

}
#endif

//信号通信——软中断 pcb中有阻塞信号集和未决信号集。
//raise 函数：给当前进程发送指定信号.abort 函数：给自己发送异常终止信号
//定时器unsigned int alarm(unsigned int seconds); 设置定时，返回0或剩余的秒数，无失败
/*信号集设定
	sigset_t  set;		// typedef unsigned long sigset_t; 
    int sigemptyset(sigset_t *set);			将某个信号集清0		 		成功：0；失败：-1
    int sigfillset(sigset_t *set);				将某个信号集置1		  		成功：0；失败：-1
    int sigaddset(sigset_t *set, int signum);		将某个信号加入信号集  		成功：0；失败：-1
    int sigdelset(sigset_t *set, int signum);		将某个信号清出信号集   		成功：0；失败：-1
    int sigismember(const sigset_t *set, int signum);判断某个信号是否在信号集中
    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);  用来屏蔽信号、解除屏蔽也使用该函数。
    how SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号 SIG_UNBLOCK 解除屏蔽的信号 SIG_SETMASK  set表示用于替代原始屏蔽及的新屏蔽集
    int sigpending(sigset_t *set);读取当前进程的未决信号集
    */
//借助SIGCHLD信号回收子进程子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收
#if 0
void sys_err(char *str)
{
    perror(str);
    exit(1);
}
void do_sig_child(int signo)                 //信号注册函数
{
    int status; 
    pid_t pid;
    while ((pid = waitpid(0, &status, WNOHANG)) > 0) {     //WNOHANG没有子进程结束，立即返回,
        if (WIFEXITED(status))           //子进程正常exit终止，返回真
            printf("child %d exit %d\n", pid, WEXITSTATUS(status));
        else if (WIFSIGNALED(status))    //信号终止为真，返回终止子进程的信号值
            printf("child %d cancel signal %d\n", pid, WTERMSIG(status));
    }
}
int main(void)
{
    pid_t pid;    int i;
    for (i = 0; i < 10; i++) {            //创建10个子进程
        if ((pid = fork()) == 0)
            break;
        else if (pid < 0)
            sys_err("fork");
    }
    if (pid == 0) {    
        int n = 1;
        while (n--) {
            printf("child ID %d\n", getpid());
            sleep(1);
        }
        return i+1;
    } else if (pid > 0) {               //信号注册
        struct sigaction act;
        act.sa_handler = do_sig_child;    //注册子信号处理函数
        sigemptyset(&act.sa_mask);          //调用信号处理函数时，所要屏蔽的信号集合置为0，
        act.sa_flags = 0;                  //0是默认属性
        sigaction(SIGCHLD, &act, NULL);    //sigaction函数 修改信号处理动作,1是要捕捉的信号，2是新的处理方式3传出旧的处理方式。	
        
        while (1) {
            printf("Parent ID %d\n", getpid());
            sleep(1);
        }
    }
    return 0;
}
#endif

/*线程 也有PCB，但没有独立的地址空间(共享)  线程：最小的执行单位 进程：最小分配资源单位
线程共享资源1.文件描述符表2.每种信号的处理方式5.内存地址空间 (.text/.data/.bss/heap/共享库)
线程同步*/
//线程函数
#if 0
void *tfn(void *arg)                        //线程运行的函数
{
	int n = 3;

	while (n--) {
		printf("thread count %d\n", n);
		sleep(1);
	}

	//return (void *)1;
    pthread_exit((void *)1);          // 将单个线程退出   void pthread_exit(void *retval);	参数：retval表示线程退出状态    
}

	pthread_t tid;                        //线程id
	void *tret;
	int err;

#if 1

	pthread_attr_t attr;			/*通过线程属性来设置游离态*/
	pthread_attr_init(&attr);        //初始化线程属性
	pthread_attr_setdetachstate(&attr,	PTHREAD_CREATE_DETACHED);     //设置线程属性，分离
	pthread_create(&tid, &attr, tfn, NULL);              //创建一个线程，参数1传出线程号，参数2线程属性，参数3：线程运行的函数指针 参数4：线程主函数执行期间所使用的参数。

#else

	pthread_create(&tid, NULL, tfn, NULL);        
	pthread_detach(tid);                    //让线程分离  ----自动退出,无系统残留资源

#endif

	while (1) {
		err = pthread_join(tid, &tret);                //阻塞等待线程退出，获取线程退出状态,参数1是线程id，参数2是退出状态 int pthread_join(pthread_t thread, void **retval); 成功：0；失败：错误号
        printf("-------------err= %d\n", err);
		if (err != 0)
			fprintf(stderr, "thread_join error: %s\n", strerror(err));
		else
			fprintf(stderr, "thread exit code %d\n", (int)tret);

		sleep(1);
	}
    //pthread_cancel(tid);                      //杀死(取消)线程  线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点),如系统调用(进入内核)，可以通过调用pthreestcancel函数自行设置一个取消点。
     pthread_attr_destroy(&attr);              //销毁线程属性所占用的资源 
#endif

//1.互斥量 
#if 0
pthread_mutex_t mutex;      //定义锁 1.静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;

void *tfn(void *arg)
{
    srand(time(NULL));

    while (1) {
        pthread_mutex_lock(&mutex);       

        printf("hello ");
        sleep(rand() % 3);	/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/
        printf("world\n");
        pthread_mutex_lock(&mutex);

        sleep(rand() % 3);
    }

    return NULL;
}

int main(void)
{
    int flg = 5;
    pthread_t tid;
    srand(time(NULL));

    pthread_mutex_init(&mutex, NULL);         // mutex==1初始化一个互斥锁(互斥量) 参数1是锁变量，参数2是锁属性int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
    pthread_create(&tid, NULL, tfn, NULL);    //restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成
    while (flg--) {

        pthread_mutex_lock(&mutex);          //加锁减1    lock尝试加锁，如果加锁不成功，线程阻塞 trylock加锁失败直接返回错误号（如：EBUSY），不阻塞

        printf("HELLO ");
        sleep(rand() % 3);
        printf("WORLD\n");
        pthread_mutex_unlock(&mutex);        //解锁+1   同时将阻塞在该锁上的所有线程全部唤醒

        sleep(rand() % 3);

    }
    pthread_cancel(tid);
    pthread_join(tid, NULL);

    pthread_mutex_destroy(&mutex);          //销毁锁

    return 0;
}

#endif
//2.读写锁  写独占、读共享  写锁优先级高
/*
	pthread_rwlock_init函数
	pthread_rwlock_destroy函数
	pthread_rwlock_rdlock函数     
	pthread_rwlock_wrlock函数
	pthread_rwlock_tryrdlock函数
	pthread_rwlock_trywrlock函数
	pthread_rwlock_unlock函数
*/
/*3.条件变量   条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。
生产者消费者模型 条件变量的优点：
相较于mutex而言，条件变量可以减少竞争。
如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，
只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。*/
#if 0
//pthread_cond_init函数 pthread_cond_destroy函数
struct msg {
    struct msg *next;
    int num;
};
struct msg *head;

pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;      //静态初始化的方法，初始化条件变量：
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;           //初始化锁

void *consumer(void *p)                                     //消费者线程函数
{
    struct msg *mp;
    for (;;) {
        pthread_mutex_lock(&lock);                          //加锁
        while (head == NULL) {          
            pthread_cond_wait(&has_product, &lock);         //阻塞等待一个条件变量，释放锁，当条件变量满足时重新获取锁1是条件变量2是锁 
        }                                                   //pthread_cond_timedwait函数限时阻塞
        mp = head;      
        head = mp->next;    			//模拟消费掉一个产品
        pthread_mutex_unlock(&lock);                         //解锁

        printf("-Consume ---%d\n", mp->num);
        free(mp);
        sleep(rand() % 5);
    }
}
void *producer(void *p)                               //生产者线程函数
{
    struct msg *mp;
    while (1) {
        mp = malloc(sizeof(struct msg));
        mp->num = rand() % 1000 + 1;             
        printf("-Produce ---%d\n", mp->num);

        pthread_mutex_lock(&lock);           //加锁
        mp->next = head;                     //生产
        head = mp;
        pthread_mutex_unlock(&lock);        //解锁

        pthread_cond_signal(&has_product);  //将等待在该条件变量上的一个线程唤醒 pthread_cond_broadcast函数唤醒全部
        sleep(rand() % 5);
    }
}
int main(int argc, char *argv[])
{
    pthread_t pid, cid;
    srand(time(NULL));

    pthread_create(&pid, NULL, producer, NULL);
    pthread_create(&cid, NULL, consumer, NULL);

    pthread_join(pid, NULL);
    pthread_join(cid, NULL);

    return 0;
}	
#endif

//4.信号量  进化版的互斥锁（1 --> N）
/*
	sem_init函数
	sem_destroy函数
	sem_wait函数        1. 信号量大于0，则信号量--	2. 信号量等于0，造成线程阻塞  （类比pthread_mutex_lock）
	sem_trywait函数	   
	sem_timedwait函数	
	sem_post函数         将信号量++，同时唤醒阻塞在信号量上的线程  （类比pthread_mutex_unlock）
*/
//进程间同步 1.互斥量mutex 但应在pthread_mutex_init初始化之前，修改其属性为进程间共享， pthread_mutexattr_setpshared(&mm->mutexattr, PTHREAD_PROCESS_SHARED); 
//2.文件锁	借助 fcntl函数来实现锁机制。	操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作




/**
 * 网络编程
 * 
 * 
 */
//server 作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。
#if 0
#define MAXLINE 80
#define SERV_PORT 6666          

int main(void)
{
	struct sockaddr_in servaddr, cliaddr;       //网络套接字信息结构体 包括1.地址结构类型2.端口号3.	IP地址
	socklen_t cliaddr_len;
	int listenfd, connfd;
	char buf[MAXLINE];
	char str[INET_ADDRSTRLEN];
	int i, n;

	listenfd = socket(AF_INET, SOCK_STREAM, 0);  //socket函数打开一个网络通讯端口，成功返回一个文件描述符，失败-1，参1.地址结构类型AF_INET是ipv4 AF_INET6是ipv6 AF_UNIX 本地协议 
                                                 //第二个参数是协议类型SOCK_STREAM代表tcp SOCK_DGRAM代表udp等 第三个传0代表默认
	bzero(&servaddr, sizeof(servaddr));          //清空servaddr 
	servaddr.sin_family = AF_INET;               //初始化servaddr 地址结构类型
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//设置ip地址，网络地址为INADDR_ANY，这个宏表示本地的所有网卡的任意IP地址 ，htonl转换字节序
                                                 //h表示host，n表示network，l表示32位长整数，s表示16位短整数
	servaddr.sin_port = htons(SERV_PORT);        //设置端口

	bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr));    //bind函数绑定套接字与ip端口信息  参1.监听套接字2.信息结构体（注意转换）3.信息结构体长度
	listen(listenfd, 20);                                              //lisen函数监听连接 参数1.用来监听的套接字，2..最多允许有20个客户端处于连接待状态，如果接收到更多的连接请求就忽略。         

	printf("Accepting connections ...\n");
	while (1) {
		cliaddr_len = sizeof(cliaddr);      //传入传出参数 传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度
		connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &cliaddr_len);//accept函数阻塞等待连接，接受连接 返回客户端文件描述符，参数1.监听文件描述符，2.传出客服端信息结构体3.客户端信息结构体长度
		n = read(connfd, buf, MAXLINE);
		printf("received from %s at PORT %d\n",  
		inet_ntop(AF_INET, &cliaddr.sin_addr, str, sizeof(str)),     //inet_ntop函数 成功返回点分十进制并赋值给str 网络ip转换点分十进制   inet_pton 
		ntohs(cliaddr.sin_port));
		for (i = 0; i < n; i++)
			buf[i] = toupper(buf[i]);
		write(connfd, buf, n);
		close(connfd);
	}
	return 0;
}
#endif

//client的作用是从命令行参数中获得一个字符串发给服务器，然后接收服务器返回的字符串并打印。
#if 0
#define MAXLINE 80
#define SERV_PORT 6666

int main(int argc, char *argv[])
{
	struct sockaddr_in servaddr;
	char buf[MAXLINE];
	int sockfd, n;
    char *str;

	if (argc != 2) {
		fputs("usage: ./client message\n", stderr);   //写入stderr文件
		exit(1);
	}
    str = argv[1];

	sockfd = socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	inet_pton(AF_INET, "127.0.0.1", &servaddr.sin_addr); //inet_pton函数将点分十进制转换为网络字节序并赋值给第三参数servaddr.sin_addr
	servaddr.sin_port = htons(SERV_PORT);

	connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr));   //connect函数连接服务器 参数1.连接的套接字2.服务器信息3.服务器信息大小

	write(sockfd, str, strlen(str));

	n = read(sockfd, buf, MAXLINE);
	printf("Response from server:\n");
	write(STDOUT_FILENO, buf, n);
	close(sockfd);

	return 0;
}
#endif

/**
 * 多进程并发服务器 
 * 1.多进程并发 文件描述符个数有关
 * 2.多线程并发 文件描述符个数有关
 * 3.io多路复用 不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。
 */
//a. select 文件描述符个数有关(不能改变) 1024

