#  Linux内核组成
————————————————进程管理 内存管理 文件系统 设备驱动 系统调用 网络协议栈
## 一. linux基础
**cpu缓存**
1. linux内核之cpu缓存
                 ----位于CPU与内存之间的临时数据交换器
   高速缓存其实就是一组称之为缓存行(Cache Line)的固定大小的数据块组成的
2. cpu的三级缓存
                 ----CPU缓存通常分成了三个级别：L1，L2，L3
   L1 缓存每个核上其实有两个 L1 缓存, 一个用于存数据的 L1d Cache（Data Cache），一个用于存指令的 L1i Cache（Instruction Cache）
3. CPU缓存一致性协议(MESI)
                 ----为了保证多个CPU缓存中共享数据的一致性
    缓存行(Cache Line)的四种状态 MESI（Modified Exclusive Shared Or Invalid）
4. CPU 存储模型简介
                 ----为了避免阻塞导致时间的浪费
   (1) 存储缓存
   (2) 无效队列
5. 乱序执行
                 ----允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术

**linuxIO之IO与网络模型**
1. Linux内核针对不同并发场景的工具实现
  atomic 原子变量--多核竞争数据总线时，提供Lock指令进行锁总线操作。
  spinlock 自旋锁 --自旋锁将当前线程不停地执行循环体，而不改变线程的运行状态，在CPU上实现忙等，以此保证响应速度更快
  mutex 互斥锁    --为了控制同一时刻只有一个线程进入临界区，让无法进入临界区的线程休眠。
  rw-lock 读写锁  
  preempt 抢占    
  per-cpu 变量     --linux为解决cpu 各自使用的L2 cache 数据与内存中的不一致的问题
2. I/O 与网络模型
  阻塞 & 非阻塞
  多路复用
  Signal IO          --Linux内核某个IO事件ready，通过kill出一个signal，应用程序在signal IO上绑定处理函数
  异步 IO             --事件ready主线程做别的事，后台线程处理
  libevent

**Linux中断机制**
> ---Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。
>

Linux 将中断处理过程分成了两个阶段
1. 上半部用来快速处理中--硬中断--由硬件产生的 
2. 下半部用来延迟处理上半部未完成的工作  --软中断--内核线程
 
 proc 文件系统：是一种内核空间和用户空间进行通信的机制，可以用来查看内核的数据结构，或者用来动态修改内核的配置。
   /proc/softirqs 提供了软中断的运行情况；
   /proc/interrupts 提供了硬中断的运行情况。
 
**linux系统调用**     ----用户态->内核态->用户态
1. 系统调用过程
  函数的系统调用在syscalls.list表中定义
  glibc库会调用脚本make_syscall.sh将其封装为宏
  这些宏会通过T_PSEUDO函数来调用（实际上使用的则是DO_CALL(syscall_name, args)）
  接下来32位与64位不同
  **32位调用过程**
  执行DO_CALL 请求参数放在寄存器 系统调用的名称，得到系统调用号，放在寄存器 eax 然后执行ENTER_KERNEL
  ENTER_KERNEL实际调用的是80软中断，以此陷入内核，调用对应的回调函数
  回调函数取出参数与命令号，在系统调用表中找到相应的函数进行调用
  最后调用INTERRUPT_RETURN 实际使用的是iret指令将原来用户保存的现场包含代码段、指令指针寄存器等恢复，并返回至用户态执行
 **64位调用过程**
  系统调用名称转换为系统调用号，放到寄存器rax  不是用中断了，而是改用syscall指令（使用特殊模块寄存器，其中就有系统调用）
  当 syscall 指令调用的时候，会从寄存器里面拿出函数地址来调用，也就是调用 entry_SYSCALL_64
  保存很多寄存器到 pt_regs 结构里面
  进入两个可选择分支
  (1).fastpath分支--检测等操作，最后系统调用表查找
  (2).slow_path分支 --检测等操作，最后系统调用表查找
  最后调用INTERRUPT_RETURN 实际使用的是iret指令将原来用户保存的现场包含代码段、指令指针寄存器等恢复，并返回至用户态执行
2. 系统调用表的生成
   
     1. 任务空间管理
        1. 进程内存管理
用户态包括
 代码段
 全局变量
 常量字符串
 函数栈，包括函数调用，局部变量，函数参数等
 堆：malloc 分配的内存等
 内存映射，如 glibc 的调用， glibc 的代码是以 so 文件的形式存在的，也需要放在内存里面。
 
        2.  内核态包括
 内核部分的代码
 内核中全局变量
 task_struct
 内核栈
 在内核里面也有动态分配的内存
 虚拟地址到物理地址的映射表
    2. ##进程在内核态中通过task_struct管理，里面包括mm_struct
 ##mm_struct保存了0-3G虚拟地址各部分的起始与结束位置以及映射
```
struct mm_struct {
......    
    unsigned long mmap_base;           ### 0-4G虚拟地址各部分的起始与结束位置以及映射
    unsigned long mmap_legacy_base;	
......    
    struct vm_area_struct *mmap;     ###描述这些区域的属性的结构体		
    struct rb_root mm_rb;  
......    
}
```

 3. ###########内核态结构##########
内核态的虚拟空间和进程是无关的，即所有进程通过系统调用进入内核后，看到的虚拟地址空间是一样的
32位
 ![32位](https://user-images.githubusercontent.com/87457873/128136124-77efb3fa-d616-49a4-90e3-93f47a64eca3.png)
     * 直接映射区  
                             -----该区域用于和物理内存进行直接映射
    * high_memory
    * 内核动态映射空间
                            --使用 alloc_pages() 函数的时候，在物理内存的高端内存得到 struct page 结构，可以调用 kmap() 将其映射到这个区域
    * 固定映射区
                            ---称为固定映射区域，主要用于满足特殊需求
     * 临时映射区
                             ----主要用于当需要写入物理内存或主存时的操作，如写入文件时使用。
64位
![64位](https://user-images.githubusercontent.com/87457873/128136164-88490bdb-e064-4fc3-bfcc-f2eadbbb5e73.png)


**linux启动**
1. 实模式（16位）   ---在此模式下地址访问的是真实地内存地址所在位置。在此模式下，可以使用20位（1MB）的地址空间
2. 保护模式（32位）   ----采用虚拟内存、页等机制对内存进行了保护，比起实模式更为安全可靠，同时也增加了灵活性和扩展性。
     实模式采取内存段来管理 0 - 0xFFFFF的这1M内存空间，但是由于只有16位寄存器，所以最大地址只能表示为0xFFFFF（64KB)
      因此不得不采取将内存按段划分为64KB的方式来充分利用1M空间。采取段选择子 + 偏移量的表示法。这种方法在保护模式中对于页的设计上也沿用了下来
>      PhysicalAddress = Segment Selector * 16 + Offset
3. BLOS到BootLoader
                             -----BIOS执行程序存储在ROM中，起始位置为0XFFFF0
   1. 用中断向量表执行中断服务程序-----中断服务程序，处理器处理“急件”，可理解为是一种服务，是通过执行事先编好的某个特定的程序来完成的
   2. BIOS程序会选择一个启动设备，并将控制权转交给启动扇区中的代码
                              -----主要工作即使用中断向量和中断服务程序完成BootLoader的加载
   3. BootLoader的工作
               1. 将boot.img加载至0X7C00的位置启动   ---- boot.img  安装在启动盘的第一个扇区 仅仅是起到一个引导的作用，指向后续的核心镜像文件
               2. boot.img加载core.img的第一个扇区 diskboot.img
               3. diskboot.img加载core.img的其他部分模块----解压缩程序 lzma_decompress.img  kernel.imggrub 的内核  最后是各个模块 module 对应的映像
               4. 加载完core之后，启动grub_main函数。 ----4、grub_main函数初始化控制台，计算模块基地址，设置 root 设备，读取 grub 配置文件，加载模块。
                  最后，将 GRUB 置于 normal 模式,grub_normal_execute调用显示一个菜单列出所用可用的操作系统
               5. 当某个操作系统被选择之后，grub_menu_execute_entry 开始执行，它将调用 GRUB 的 boot 命令，来引导被选中的操作系统
               6. 后面的程序变大，lzma_decompress.img 调用 real_to_prot，切换到保护模式
               7. 内核启动的main函数执行

**内核启动**
1. 新旧中断的交替
            ----中断描述符表IDT和全局描述符表GDT代替中断向量表
    1.   GDT ，在系统中唯一的存放段寄存器内容（段描述符）的数组，配合程序进行保护模式下的段寻址。它在操作系统的进程切换中具有重要意义，可理解为所有进程的总目录表
    2.  IDT       保存保护模式下所有中断服务程序的入口地址
2. 打开A20    ----A20启用是一个标志性的动作 意味着CPU可以进行32位寻址  A20地址线的启用相当于关闭CPU在实模式下寻址的“回滚”机制
3. setup程序将CPU工作方式设为保护模式，head在空间创建了内核分页机制
4. 进入main函数   ----完成一系列的初始化后才会打开新的中断，从而使内核正式运行起来


**内核初始化**   ----init/main.c中的start_kernel()
1. 创建0号进程（idle进程）：INIT_TASK(init_task)
 ----它没有自己的用户空间，用于包括内存、页表、必要数据结构、信号、调度器、硬件设备等的初始化
       开启了kernel_init和kthreadd进程，kthreadd进程内核用于管理调度其他的内核线程的守护线程。
       启动kernel_init内核线程执行到最后会通过execve系统调用执行转变为我们所熟悉的init进程
       在最后init_task将变成一个idle进程，用于在CPU没有进程运行时运行它，它在此时仅仅用于空转。---0号进程
2. 异常处理类中断服务程序挂接：trap_init()

3. 内存初始化：mm_init()
   ----在mm_init()中进行，
4. 调度器初始化sched_init()

5. 剩余初始化：rest_init()  
    ----主要包括了区分内核态和用户态、初始化1号进程和初始化2号进程
    1. 区分内核态用户态
    2. 初始化1号进程 ---所有用户进程共个祖先
     kernel_thread创建第二个进程 调用可init可执行文件，init进程最终会去创建所有的应用进程。它将运行一个用户进程，并从此开始形成用户态进程树
    3. 初始化2号进程----所有线程运行的祖先 
     kthreadd2号进程会在内核中负责创建所有的内核线程


##一. 内存管理
**1. 硬件原理 和 分页管理**
    1. 内存分页
     v=(p,d) 如果地址是32位，0x12345670
     ##MMU的管理是把每一页的内存分成4K，那么其中的670是页内偏移，作为d；0x12345 是页号，作为p。
     ##通过虚拟地址去查对应的物理地址，用0x12345去查一张页表，页表（Page table）本身在内存。
    2. CPU中的高速单元tlb
           ----它是页表的高速缓存。CPU就不需要在内存里读页表，直接在tlb中读取，从虚拟地址到物理地址的映射。如果tlb中读取不到，才回到内存里读取页表映射，并且在tlb中命中。
    3. 页表（Page table）记录的页权限
      页表项，除了有虚拟地址到物理地址的映射之外还可以标注这个页的 RWX权限和 kernel和user模式权限

            meltdown 攻击原理： 基于时间的 旁路攻击 side-channel


    4. 内存分Zone     ----内存的分Zone，全都是物理地址的概念。内存条，被分为三个Zone

           分DMA Zone的原因，是DMA引擎的缺陷。DMA引擎 可以直接访问内存空间的地址，但不一定能够访问到所有的内存，访问内存时会存在一定的限制。


         1.  lowmem包括了 normal + DMA   开机就把lowmem的物理地址一一映射到虚拟地址
   ######这段地址的虚拟地址和物理地址是直接线性映射，通过linux的两个api （phys_to_virt / virt_to_phys）在虚拟和物理之间进行映射, highmem 不能直接用
         2.  内核空间一般不使用highmem，内核一般使用kmalloc在lowmem申请内存，使用 kmmap在highmem 申请内存。
                            -----------应用程序一样可以申请 lowmem 和highmem
    5. 硬件层的内存管理- buddy算法
                    -------每个zone都会使用buddy算法，把所有的空闲页面变成2的n次方进行管理
     连续的空闲内存少解决（DMA需要连续内存）
        1.reserved
        2.CMA：continuous memory allocation
                    ————当DMA想拿CMA区域的时候，要么移走，要么抛弃。总之，必须保证DMA需要这片CMA区域的时候，之前占着CMA的统统滚蛋 
**2. 内存的动态申请和释放** 
    ![](https://user-images.githubusercontent.com/87457873/127087352-9e0e0697-b1f8-45d8-949b-7a7e17b503f8.png)
`注意，slab申请和分配的都是只针对内核空间，与用户空间申请分配内存无关。用户空间的malloc和free调用的是libc。`
      1.  slab       主要分为两类：
                1.一、常用数据结构像 nfsd_drc， UDPv6，TCPv6 ，这些经常申请和释放的数据结构
                2.常规的小内存申请，做的slab。例如 kmalloc-32，kmalloc-64， kmalloc-96， kmalloc-128
       2. mallopt
               ——————在C库中有一个api是mallopt，可以控制一系列的选项
       3. Linux内存分配的lazy行为
            ————Linux总是以最lazy的方式，给应用程序分配内存
       4. kmalloc，vmalloc 和malloc的区别

* kmalloc：申请内存，一般在低端内存区。申请到时，内存已经映射过了，不需要再去改进程的页表。所以，申请到的物理页是连续的。
* vmalloc：申请内存，申请到就拿到内存，并且已经修改了进程页表的虚拟地址到物理地址的映射。vmalloc()申请的内存并不保证物理地址的连续。
* 用户空间的malloc：申请内存，申请到并没有拿到，写的时候才去拿到。拿到之后，才去改页表。申请成功，页表只读，只有到写时，发生page fault，才去buddy拿内存。
* kmalloc和vmalloc针对内核空间，malloc针对用户空间。这些内存，可以来自任何一个Zone。
* 无论是kmalloc，vmalloc还是用户空间的malloc，都可以使用内存条的不同Zone，无论是highmem zone、lowmem zone 和 DMA zone。
>       malloc 100M内存成功时，其实并没有真实拿到。只有当100M内存中的任何一页，被写一次的时候，才成功。
>       当内核使用kmalloc申请内存时，就真实的分配相应的内存，不使用lazy机制。
 内存OOM  
>  如果在从buddy拿不到内存时，会触发Linux对所有进程进行OOM打分。当Linux出现内存耗尽，就kill一个oom score 最高的那个进程。oom_score
> 
3. 进程的内存消耗和泄漏
 